# -*- coding: utf-8 -*-
"""StockModel_YF_Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NXnvGBzApKz4dMc7GuNzhKyAlmTs4vYl
"""

#Program to predict stock prices

#Install dependencies
import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.model_selection import train_test_split

#Get the stock data
#raw prices w/dividends and splits
df = yf.download('AAPL', start='2010-01-01', end='2024-12-31', auto_adjust=False, actions = True)
#Print data
print("\n")
print(df.head())

df = df[['Adj Close']]
print(df.head())

"""✅ When it's fine to use Close:
You're not analyzing long-term trends across dividends or stock splits.

Your model is short- to medium-term, e.g., predicting tomorrow’s price or trends within a few weeks/months.

You're using recent data, post-split and post-dividend adjustments.

⚠️ When to prefer Adj Close:
You're using long-term historical data that spans multiple splits or dividend events.

You want to account for total return (price + dividends).

Your features depend on price movement patterns over years (e.g., 5-year trend analysis).

Simple Rule of Thumb:
Short-term → Close is fine
Long-term / accuracy across events → Adj Close preferred

Since you're using yfinance, and Adj Close is sometimes not returned depending on the download method, sticking with Close is totally reasonable — especially if your time window doesn't cover big corporate actions.
"""

forecast_out = 30
df['Prediction'] = df['Adj Close'].shift(-forecast_out)
print(df.tail())

#creating independent data set (x)
x = np.array(df.drop(columns=['Prediction']))
x = x[:-forecast_out]
print(x)

### dependednt data set (y)
y = np.array(df['Prediction'])
y = y[:-forecast_out]
print(y)

#80% training, 20% testing data
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2)

#create and train Support Vector Machine
#regression - type of supervised learning
svr_rbf = SVR(kernel='rbf', C=1e3, gamma=0.1)
svr_rbf.fit(x_train, y_train)

#testing model - score returns coefficient of determination r^2 of the prediction.
#best possible core is 1.0
svm_confidence = svr_rbf.score(x_test, y_test)
print("svm confidence: ", svm_confidence)

lr = LinearRegression()
lr.fit(x_train, y_train)

lr_confidence = lr.score(x_test, y_test)
print("lr confidence: ", lr_confidence)

x_forecast = np.array(df.drop(columns=['Prediction']))[-forecast_out:]
print(x_forecast)

LR_PREDICTION = lr.predict(x_forecast)
print(LR_PREDICTION)

svm_prediction = svr_rbf.predict(x_forecast)
print(svm_prediction)